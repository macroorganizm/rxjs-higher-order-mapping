# Исчерпывающий гайд в Higher-Order RxJs Mapping Operators: switchMap, mergeMap, concatMap (and exhaustMap)

*Плохой перевод [этой](https://blog.angular-university.io/rxjs-higher-order-mapping) статьи*

Например *некоторые из наиболее используемых* в повседневной работе RxJs операторов, это операторы отображения высшего порядка(RxJs higher-order mapping operators): switchMap, mergeMap, concatMap и exhaustMap.

Для примера, **большинство сетевых запросов в нашей программе** используют эти операторы, поэтому знакомство с ними является ключевым при написании почти любой реактивной программы.

Понимание какой(и почему) оператор использовать данной конкретной ситуации *может быть слегка запутанным*, поэтому мы часто представляем себе как эти операторы работают и почему они названы именно таким образом.

Эти операторы могут казаться не связанными друг с другом, но мы действительно считаем, что их следует рассматривать в совокупности, потому как неверный выбор подходящего оператора может привести к неожиданному(и странному) поведению наших прогамм

### Почему операторы отображения(mapping) сбивают с толку? ### 
Причина заключатеся в том, что для понимания этих операторов нам необходимо, в первую очередь, понимать ту стратегию, которая применяется для комбинирования Observable, внутри каждого из этих операторов.

Вместо попыток понять switchMap "в лоб", нам нужно, для начала, понять что есть "переключкение"(switching) применительно к Observasble, вместо погружения непосредственно в concatMap, нам нужно сначала понять как происходит конкатенация таких штук, как Observable.

Мы будем объяснять концепции используя комбинацию диаграм и практических примеров(включая запускаемый код).

По прочтению вы будете знать как именно работают эти операторы, когда и почему использовать каждый их них и почему их назвали именно так.

## Содержание ##
В этой статье мы затронем следующие темы(большинство тем переводить не буду, так как в большинстве своем эти термины используются в виде англицизмов):
* The RxJs Map Operator
* What is higher-order Observable Mapping
* Observable Concatenation(конкатенация т.е. сложение)
* The RxJs concatMap Operator
* Observable Merging(Слияние)
* The RxJs mergeMap Operator
* Observable Switching(Переключение)
* The RxJs switchMap Operator
* The Exhaust(Истощение) strategy
* The RxJs exhaustMap Operator
* Как выбрать правильный mapping Operator?
* GitHub репозиторий (с примерами кода)
* Выводы

Также обратите внимание, что эта статья это часть постоянной [серии по RxJS](https://blog.angular-university.io/tag/rxjs). Короче - погнали!

### RxJS Map оператор ###

Давайте для начала разберемся что эти *mapping* операторы делают в-общем.

Из имен этих операторов следует, что они выполняют какое-то отображение(mapping), но что и на что они *мапят*? Давайте сначала взглянем на диаграмму оператора RxJS Map:
![img](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-map-operators/01-rxjs-map.png)

#### Как работает базовый Map оператор ####
С оператором *map* мы можем взять входной поток(со значениями 1, 2, 3) и из него мы можем создать исходящий поток(со значениями 10, 20, 30).

Значения исхлдящего потока(внизу на диаграмме) получены посредством применения функции к значениям, взятым из входного потока: эта функция попросу умножает эти значения на 10.

Таким образом *map* оператор это про *маппинг значений* из входного Observable. Ниже пример того как можно использовать это для обработки HTTP запроса:

```
const http$ : Observable<Course[]> = this.http.get('/api/courses');

http$
    .pipe(
        tap(() => console.log('HTTP request executed')),
        map(res => Object.values(res['payload']))
    )
    .subscribe(
        courses => console.log("courses", courses)
    );
```
  В этом примере мы создаем один HTTP Observable, который делает запрос к серверу и мы подписываемся на него. Observable порождает значение с ответом от сервера(в JSON формате).
  В этом случае в HTTP-ответе, данные обернуты всвойство *payload*, поэтому, чтобы получить эти данные мы применяем оператор RxJS map. *Функция-маппер*  получает JSON-ответ и извлекает значение свойства *payload*.
  Теперь, когда мы рассмотрели базовый *маппинг*, давайте поговорим о *маппинге высшего порядка*
  
### Что такое Higher-Order Observable Mapping ###
В *Higher-Order Observable Mapping*, в отличие от *маппинга* обычного значения(напр. 1) в другое значение(10), мы мапим значение в Observable!

  Результат - higher-order Observable. Это просто Observable, как и любой другой, но его значения сами являются Observable'ми на котоые можно подписываться.

  Это выглядит чрезмерно переусложненным, но на самом деле подобный тип маппинга происходит повсеместно. Давайте рассмотрим приактический пример подобного *маппинга*. Для примера возьмем некую пеактивную форму Angular, которая порождает валидные значения формы постоянно в  виде Observable:
```
@Component({
    selector: 'course-dialog',
    templateUrl: './course-dialog.component.html'
})
export class CourseDialogComponent implements AfterViewInit {

    form: FormGroup;
    course:Course;

    @ViewChild('saveButton') saveButton: ElementRef;

    constructor(
        private fb: FormBuilder,
        private dialogRef: MatDialogRef<CourseDialogComponent>,
        @Inject(MAT_DIALOG_DATA) course:Course) {

        this.course = course;

        this.form = fb.group({
            description: [course.description, 
                          Validators.required],
            category: [course.category, Validators.required],
            releasedAt: [moment(), Validators.required],
            longDescription: [course.longDescription,
                              Validators.required]
        });
    }
}
```
  Реактивная форма предоставляет Observable `this.form.valueChanges`, который порождает последнее значение формы, после действий пользователя. Это будет наш *исходный* Observable.
  Наща цель - сохранить некоторые из этих изменеий, которые происходят постоянно, в качестве черновика. Таким образом данные будут постоянно сохраняться в процессе заполнения пользователем формы, что даст возможность избежать потери данных при случайной перезагрузке формы.
  
#### Почему Higher-Order Observables? ####
